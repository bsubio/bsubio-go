// Package bsubio provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package bsubio

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for JobStatus.
const (
	JobStatusClaimed    JobStatus = "Claimed"
	JobStatusCreated    JobStatus = "Created"
	JobStatusFailed     JobStatus = "Failed"
	JobStatusFinished   JobStatus = "Finished"
	JobStatusInProgress JobStatus = "InProgress"
	JobStatusLoaded     JobStatus = "Loaded"
	JobStatusPending    JobStatus = "Pending"
	JobStatusPreparing  JobStatus = "Preparing"
)

// Defines values for ListJobsParamsStatus.
const (
	ListJobsParamsStatusClaimed    ListJobsParamsStatus = "Claimed"
	ListJobsParamsStatusCreated    ListJobsParamsStatus = "Created"
	ListJobsParamsStatusFailed     ListJobsParamsStatus = "Failed"
	ListJobsParamsStatusFinished   ListJobsParamsStatus = "Finished"
	ListJobsParamsStatusInProgress ListJobsParamsStatus = "InProgress"
	ListJobsParamsStatusLoaded     ListJobsParamsStatus = "Loaded"
	ListJobsParamsStatusPending    ListJobsParamsStatus = "Pending"
	ListJobsParamsStatusPreparing  ListJobsParamsStatus = "Preparing"
)

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error   *string `json:"error,omitempty"`
	Success *bool   `json:"success,omitempty"`
}

// Job defines model for Job.
type Job struct {
	// ClaimedAt When job was claimed by worker
	ClaimedAt *time.Time `json:"claimed_at"`

	// ClaimedBy Worker ID that claimed the job
	ClaimedBy *string `json:"claimed_by"`

	// CreatedAt Job creation timestamp
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DataSize Size of uploaded data in bytes
	DataSize *int64 `json:"data_size,omitempty"`

	// ErrorCode Error code if job failed
	ErrorCode *string `json:"error_code"`

	// ErrorMessage Error message if job failed
	ErrorMessage *string `json:"error_message"`

	// FinishedAt When job finished (success or failure)
	FinishedAt *time.Time `json:"finished_at"`

	// Id Unique job identifier
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Status Current job status
	Status *JobStatus `json:"status,omitempty"`

	// Type Processing type
	Type *string `json:"type,omitempty"`

	// UpdatedAt Last update timestamp
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// UploadToken Token for uploading data (only present in Created state)
	UploadToken *string `json:"upload_token,omitempty"`

	// UserId User who created the job
	UserId *string `json:"user_id,omitempty"`
}

// JobStatus Current job status
type JobStatus string

// ProcessingType defines model for ProcessingType.
type ProcessingType struct {
	// Description Human-readable description
	Description *string `json:"description,omitempty"`

	// Name Type identifier used when creating jobs
	Name *string `json:"name,omitempty"`

	// Timeout Processing timeout in seconds
	Timeout *int `json:"timeout,omitempty"`
}

// JobId defines model for JobId.
type JobId = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	// Status Filter by job status
	Status *ListJobsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Limit Maximum number of jobs to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListJobsParamsStatus defines parameters for ListJobs.
type ListJobsParamsStatus string

// CreateJobJSONBody defines parameters for CreateJob.
type CreateJobJSONBody struct {
	// Type Processing type (see /v1/types for available types)
	Type string `json:"type"`
}

// UploadJobDataMultipartBody defines parameters for UploadJobData.
type UploadJobDataMultipartBody struct {
	// File File to process
	File openapi_types.File `json:"file"`
}

// UploadJobDataParams defines parameters for UploadJobData.
type UploadJobDataParams struct {
	// Token Upload token from job creation
	Token string `form:"token" json:"token"`
}

// CreateJobJSONRequestBody defines body for CreateJob for application/json ContentType.
type CreateJobJSONRequestBody CreateJobJSONBody

// UploadJobDataMultipartRequestBody defines body for UploadJobData for multipart/form-data ContentType.
type UploadJobDataMultipartRequestBody UploadJobDataMultipartBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListJobs request
	ListJobs(ctx context.Context, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJobWithBody request with any body
	CreateJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJob(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJob request
	DeleteJob(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelJob request
	CancelJob(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobLogs request
	GetJobLogs(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobOutput request
	GetJobOutput(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitJob request
	SubmitJob(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTypes request
	GetTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadJobDataWithBody request with any body
	UploadJobDataWithBody(ctx context.Context, jobId openapi_types.UUID, params *UploadJobDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersion request
	GetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListJobs(ctx context.Context, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJob(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJob(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelJob(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobLogs(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobLogsRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobOutput(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobOutputRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitJob(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadJobDataWithBody(ctx context.Context, jobId openapi_types.UUID, params *UploadJobDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadJobDataRequestWithBody(c.Server, jobId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListJobsRequest generates requests for ListJobs
func NewListJobsRequest(server string, params *ListJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateJobRequest calls the generic CreateJob builder with application/json body
func NewCreateJobRequest(server string, body CreateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateJobRequestWithBody generates requests for CreateJob with any type of body
func NewCreateJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJobRequest generates requests for DeleteJob
func NewDeleteJobRequest(server string, jobId JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, jobId JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelJobRequest generates requests for CancelJob
func NewCancelJobRequest(server string, jobId JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobLogsRequest generates requests for GetJobLogs
func NewGetJobLogsRequest(server string, jobId JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobOutputRequest generates requests for GetJobOutput
func NewGetJobOutputRequest(server string, jobId JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs/%s/output", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitJobRequest generates requests for SubmitJob
func NewSubmitJobRequest(server string, jobId JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs/%s/submit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTypesRequest generates requests for GetTypes
func NewGetTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadJobDataRequestWithBody generates requests for UploadJobData with any type of body
func NewUploadJobDataRequestWithBody(server string, jobId openapi_types.UUID, params *UploadJobDataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/upload/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVersionRequest generates requests for GetVersion
func NewGetVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListJobsWithResponse request
	ListJobsWithResponse(ctx context.Context, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error)

	// CreateJobWithBodyWithResponse request with any body
	CreateJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobResponse, error)

	CreateJobWithResponse(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobResponse, error)

	// DeleteJobWithResponse request
	DeleteJobWithResponse(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// CancelJobWithResponse request
	CancelJobWithResponse(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*CancelJobResponse, error)

	// GetJobLogsWithResponse request
	GetJobLogsWithResponse(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*GetJobLogsResponse, error)

	// GetJobOutputWithResponse request
	GetJobOutputWithResponse(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*GetJobOutputResponse, error)

	// SubmitJobWithResponse request
	SubmitJobWithResponse(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*SubmitJobResponse, error)

	// GetTypesWithResponse request
	GetTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTypesResponse, error)

	// UploadJobDataWithBodyWithResponse request with any body
	UploadJobDataWithBodyWithResponse(ctx context.Context, jobId openapi_types.UUID, params *UploadJobDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadJobDataResponse, error)

	// GetVersionWithResponse request
	GetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionResponse, error)
}

type ListJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Jobs *[]Job `json:"jobs,omitempty"`

			// Total Total number of jobs (before pagination)
			Total *int `json:"total,omitempty"`
		} `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data    *Job  `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data    *Job  `json:"data,omitempty"`
		Success *bool `json:"success,omitempty"`
	}
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON400 *Error
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r CancelJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetJobLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Error
}

// Status returns HTTPResponse.Status
func (r GetJobOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
		Success *bool   `json:"success,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON404 *NotFound
}

// Status returns HTTPResponse.Status
func (r SubmitJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Types *[]ProcessingType `json:"types,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadJobDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DataSize Size of uploaded file in bytes
		DataSize *int    `json:"data_size,omitempty"`
		Message  *string `json:"message,omitempty"`
		Success  *bool   `json:"success,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Error
	JSON404 *NotFound
	JSON413 *Error
}

// Status returns HTTPResponse.Status
func (r UploadJobDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadJobDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Build   *string `json:"build,omitempty"`
		Server  *string `json:"server,omitempty"`
		Version *string `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListJobsWithResponse request returning *ListJobsResponse
func (c *ClientWithResponses) ListJobsWithResponse(ctx context.Context, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error) {
	rsp, err := c.ListJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsResponse(rsp)
}

// CreateJobWithBodyWithResponse request with arbitrary body returning *CreateJobResponse
func (c *ClientWithResponses) CreateJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobResponse, error) {
	rsp, err := c.CreateJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobResponse(rsp)
}

func (c *ClientWithResponses) CreateJobWithResponse(ctx context.Context, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobResponse, error) {
	rsp, err := c.CreateJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobResponse(rsp)
}

// DeleteJobWithResponse request returning *DeleteJobResponse
func (c *ClientWithResponses) DeleteJobWithResponse(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error) {
	rsp, err := c.DeleteJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// CancelJobWithResponse request returning *CancelJobResponse
func (c *ClientWithResponses) CancelJobWithResponse(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*CancelJobResponse, error) {
	rsp, err := c.CancelJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelJobResponse(rsp)
}

// GetJobLogsWithResponse request returning *GetJobLogsResponse
func (c *ClientWithResponses) GetJobLogsWithResponse(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*GetJobLogsResponse, error) {
	rsp, err := c.GetJobLogs(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobLogsResponse(rsp)
}

// GetJobOutputWithResponse request returning *GetJobOutputResponse
func (c *ClientWithResponses) GetJobOutputWithResponse(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*GetJobOutputResponse, error) {
	rsp, err := c.GetJobOutput(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobOutputResponse(rsp)
}

// SubmitJobWithResponse request returning *SubmitJobResponse
func (c *ClientWithResponses) SubmitJobWithResponse(ctx context.Context, jobId JobId, reqEditors ...RequestEditorFn) (*SubmitJobResponse, error) {
	rsp, err := c.SubmitJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitJobResponse(rsp)
}

// GetTypesWithResponse request returning *GetTypesResponse
func (c *ClientWithResponses) GetTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTypesResponse, error) {
	rsp, err := c.GetTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTypesResponse(rsp)
}

// UploadJobDataWithBodyWithResponse request with arbitrary body returning *UploadJobDataResponse
func (c *ClientWithResponses) UploadJobDataWithBodyWithResponse(ctx context.Context, jobId openapi_types.UUID, params *UploadJobDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadJobDataResponse, error) {
	rsp, err := c.UploadJobDataWithBody(ctx, jobId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadJobDataResponse(rsp)
}

// GetVersionWithResponse request returning *GetVersionResponse
func (c *ClientWithResponses) GetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionResponse, error) {
	rsp, err := c.GetVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionResponse(rsp)
}

// ParseListJobsResponse parses an HTTP response from a ListJobsWithResponse call
func ParseListJobsResponse(rsp *http.Response) (*ListJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Jobs *[]Job `json:"jobs,omitempty"`

				// Total Total number of jobs (before pagination)
				Total *int `json:"total,omitempty"`
			} `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateJobResponse parses an HTTP response from a CreateJobWithResponse call
func ParseCreateJobResponse(rsp *http.Response) (*CreateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data    *Job  `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteJobResponse parses an HTTP response from a DeleteJobWithResponse call
func ParseDeleteJobResponse(rsp *http.Response) (*DeleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data    *Job  `json:"data,omitempty"`
			Success *bool `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCancelJobResponse parses an HTTP response from a CancelJobWithResponse call
func ParseCancelJobResponse(rsp *http.Response) (*CancelJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetJobLogsResponse parses an HTTP response from a GetJobLogsWithResponse call
func ParseGetJobLogsResponse(rsp *http.Response) (*GetJobLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetJobOutputResponse parses an HTTP response from a GetJobOutputWithResponse call
func ParseGetJobOutputResponse(rsp *http.Response) (*GetJobOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseSubmitJobResponse parses an HTTP response from a SubmitJobWithResponse call
func ParseSubmitJobResponse(rsp *http.Response) (*SubmitJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Success *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTypesResponse parses an HTTP response from a GetTypesWithResponse call
func ParseGetTypesResponse(rsp *http.Response) (*GetTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Types *[]ProcessingType `json:"types,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadJobDataResponse parses an HTTP response from a UploadJobDataWithResponse call
func ParseUploadJobDataResponse(rsp *http.Response) (*UploadJobDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadJobDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DataSize Size of uploaded file in bytes
			DataSize *int    `json:"data_size,omitempty"`
			Message  *string `json:"message,omitempty"`
			Success  *bool   `json:"success,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseGetVersionResponse parses an HTTP response from a GetVersionWithResponse call
func ParseGetVersionResponse(rsp *http.Response) (*GetVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Build   *string `json:"build,omitempty"`
			Server  *string `json:"server,omitempty"`
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
